/*
 * generated by Xtext 2.11.0
 */
package org.moflon.tie.gt.mosl.controlflow.language.validation

import org.eclipse.xtext.validation.Check
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.OperationCallStatement
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.MoslControlFlowPackage
import org.eclipse.emf.ecore.EClassifier
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.OperationCallStatementParameter
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.ObjectVariableStatement
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.impl.MethodDecImpl
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.MethodParameter
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.PatternStatement
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.EClassDef
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.GraphTransformationControlFlowFile
import org.eclipse.emf.ecore.EObject
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.Import
import org.eclipse.emf.ecore.EDataType
import org.eclipse.emf.ecore.EClass
import org.moflon.tie.gt.mosl.controlflow.language.utils.ControlFlowEditorModelUtil
import org.eclipse.emf.ecore.EPackage
import javax.lang.model.SourceVersion
import org.moflon.tie.gt.mosl.controlflow.language.moslControlFlow.MethodDec
import org.eclipse.emf.ecore.EOperation

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class MOSLControlFlowValidator extends BaseMOSLControlFlowValidator {

  static val CODE_PREFIX = "org.moflon.tie.gt.mosl.controlflow.language."

  public static val TOO_MANY_ARGUMENTS = CODE_PREFIX + 'tooManyArguments'
  public static val TOO_FEW_ARGUMENTS = CODE_PREFIX + 'tooFewArguments'
  public static val CANNOT_RESOLVE_TYPE = CODE_PREFIX + 'cannotResolveType'
  public static val DUPLICATE_VARIABLE_NAME = CODE_PREFIX + 'duplicateVariable'
  public static val DUPLICATE_OPERATION_DECLARATION = CODE_PREFIX + 'duplicateOperation'
  public static val IMPORT_NO_ECORE = CODE_PREFIX + "import.noEcore"
  public static val IMPORT_NO_ECORE_MESSAGE = "The file '%s' cannot be imported because it is no Ecore file."
  public static val IMPORT_FILE_DOES_NOT_EXIST = CODE_PREFIX + "import.fileDoesNotExist"
  public static val IMPORT_FILE_DOES_NOT_EXIST_MESSAGE = "The file '%s' does not exist."
  public static val IMPORT_DUPLICATE = CODE_PREFIX + "import.duplicate"
  public static val IMPORT_DUPLICATE_MESSAGE = "Import '%s' must not be declared %s."
  public static val INVALID_NAME = CODE_PREFIX + 'invalidName'
  public static val NO_THIS_VARIABLE = CODE_PREFIX + 'noThisVariable'
  public static val MISSING_OPERATION = CODE_PREFIX + 'missingOperation'
  public static val UNKNOWN_PATTERN_NAME = CODE_PREFIX + 'unknownPattern'
  public static val VARIABLE_ASSIGNED_MORE_THAN_ONCE = CODE_PREFIX + 'multipleAssignmentsToVariable'
  public static val ABSTRACT_PATTERN_INVOKED = CODE_PREFIX + 'abstractPatternInvoked'
  public static val NO_GT_IMPORT = CODE_PREFIX + 'noGTImport'

  /*@Check
   * def checkPatternName(PatternStatement patternStmt){
   * 		val gtcf = getControlFlowFile(patternStmt)
   * 		val gtFiles=resolvePatterns(gtcf.includedPatterns)
   * 		gtFiles.map[res|
   * 			val contents=res.contents
   * 			return contents.filter[content|content instanceof EditorPattern]
   * 		].reduce[patterns1,patterns2|patterns1+patterns2].filter[patternObj|
   * 			val pattern=patternObj as EditorPattern
   * 			return patternStmt.patternReference.pattern.name
   * 		]
   * }
   * 
   * def resolvePatterns(EList<IncludePattern> patternFileNames) {
   * 	return patternFileNames.map[fileName|
   * 		val url=WorkspaceHelper.getResource(fileName.importURI)
   * 		val optResource=ControlFlowEditorModelUtil.loadGTResource(fileName.importURI)
   * 		if(optResource.isPresent)
   * 			return optResource.get
   * 	]
   }*/
  @Check
  def checkParametersofMethodCall(OperationCallStatement callStatement) {
    val operation = getOperation(callStatement)
    if (operation === null)
      return
    val eparameters = operation.EParameters
    val trgTypes = eparameters.map[param|param.EType]
    val srcTypes = callStatement?.parameters?.map[param|getTypeOfCalledParameter(param)]
    if (trgTypes.size > srcTypes.size)
      error("Too few Arguments for Operation: " + operation.name + "()", callStatement,
        MoslControlFlowPackage.Literals.OPERATION_CALL_STATEMENT__PARAMETERS, TOO_FEW_ARGUMENTS)
    else if (trgTypes.size < srcTypes.size)
      error("Too many Arguments for Operation: " + operation.name + "()", callStatement,
        MoslControlFlowPackage.Literals.OPERATION_CALL_STATEMENT__PARAMETERS, TOO_MANY_ARGUMENTS)

    for (var index = 0; index < trgTypes.size; index++) {
      val srcType = srcTypes.get(index)
      if (srcType !== null && !this.isInstanceOf(srcType, trgTypes.get(index)))
        error(srcType.name + " cannot be resolved to a variable of " + trgTypes.get(index).name, callStatement,
          MoslControlFlowPackage.Literals.OPERATION_CALL_STATEMENT__PARAMETERS, CANNOT_RESOLVE_TYPE)
    }
  }

  def getOperation(OperationCallStatement callStatement) {
    return callStatement.call
  }

  def EClassifier getTypeOfCalledParameter(OperationCallStatementParameter param) {
    return param.object.EType
  }

  @Check
  def nodesOnlyAssignedOnce(PatternStatement patternstmt) {
    patternstmt.parameters.forEach [ param |
      val otherCandidates = patternstmt.parameters.filter [ candidateParam |
        candidateParam.parameter.name.equals(param.parameter.name) && candidateParam !== param
      ]
      if (!otherCandidates.empty) {
        error("Parameter " + param.parameter.name + " should only be assigned once.", patternstmt,
          MoslControlFlowPackage.Literals.PATTERN_STATEMENT__PARAMETERS, VARIABLE_ASSIGNED_MORE_THAN_ONCE)
      }
    ]
  }

  @Check
  def calledPatternShouldBeConcrete(PatternStatement patternStatement) {
    if (patternStatement.patternReference.pattern.abstract)
      error("Invoked pattern " + patternStatement.patternReference.pattern.name + " must not be abstract.",
        patternStatement, MoslControlFlowPackage.Literals.PATTERN_STATEMENT__PATTERN_REFERENCE,
        ABSTRACT_PATTERN_INVOKED)
  }

  @Check
  def noUsingDirective(GraphTransformationControlFlowFile gtcf) {
    if (gtcf.includedPatterns.empty) {
      error("No .GT files referenced", gtcf,
        MoslControlFlowPackage.Literals.GRAPH_TRANSFORMATION_CONTROL_FLOW_FILE__INCLUDED_PATTERNS, NO_GT_IMPORT)
    }
  }

  @Check
  def uniqueVariableNames(ObjectVariableStatement oVar) {
    val name = oVar.name
    var methodCall = oVar.eContainer
    while (!(methodCall instanceof MethodDecImpl)) {
      methodCall = methodCall.eContainer
      if (methodCall instanceof PatternStatement || methodCall instanceof OperationCallStatement) {
        return
      }
    }
    methodCall = methodCall as MethodDecImpl
    val contents = methodCall.eAllContents
    val result = contents.filter[obj|obj instanceof ObjectVariableStatement || obj instanceof MethodParameter].findFirst [ candidate |
      if (candidate instanceof MethodParameter) {
        val methodParam = candidate as MethodParameter
        if (methodParam.name.equals(name)) {
          return true
        }
      } else {
        val oVarCandidate = candidate as ObjectVariableStatement
        if (oVarCandidate.name.equals(name) && !(oVarCandidate === oVar)) {
          return true
        }
      }
      return false
    ]
    if (result !== null) {
      error("Multiple ObjectVariables with name " + name, oVar,
        MoslControlFlowPackage.Literals.OBJECT_VARIABLE_STATEMENT.getEStructuralFeature(
          MoslControlFlowPackage.OBJECT_VARIABLE_STATEMENT__NAME), DUPLICATE_VARIABLE_NAME)
    }
  }

  @Check
  def checkImport(Import importEcore) {
    val ecoreModel = ControlFlowEditorModelUtil.loadEcoreModel(importEcore.name)
    if (ecoreModel.present) {
      // Imports must be of type ecore.
      val classes = ControlFlowEditorModelUtil.getElements(ecoreModel.get, EClass).size
      val datatypes = ControlFlowEditorModelUtil.getElements(ecoreModel.get, EDataType).size
      if (classes + datatypes == 0) {
        error(
          String.format(IMPORT_NO_ECORE_MESSAGE, importEcore.name),
          MoslControlFlowPackage.Literals.IMPORT__NAME,
          IMPORT_NO_ECORE,
          importEcore.name
        )
      }
    } else {
      // Import files must exist.
      error(
        String.format(IMPORT_FILE_DOES_NOT_EXIST_MESSAGE, importEcore.name),
        MoslControlFlowPackage.Literals.IMPORT__NAME,
        IMPORT_FILE_DOES_NOT_EXIST,
        importEcore.name
      )
    }

    // Imports must be unique.
    val file = importEcore.eContainer as GraphTransformationControlFlowFile
    val importDeclarationCount = file.imports.filter[name.equals(importEcore.name)].size
    if (importDeclarationCount !== 1) {
      warning(
        String.format(IMPORT_DUPLICATE_MESSAGE, importEcore.name, getTimes(importDeclarationCount)),
        MoslControlFlowPackage.Literals.IMPORT__NAME,
        IMPORT_DUPLICATE,
        importEcore.name
      )
    }
  }

  @Check
  def methodDeclaredInEcoreFile(MethodDecImpl methodImpl) {
    val methodName = methodImpl.name
    val eClass = methodImpl.eContainer as EClassDef
    val eClassCandidates = getEClassCandidatesFromSpec(eClass.name.name,
      eClass.eContainer as GraphTransformationControlFlowFile)
    val candidatesWithSameNames = newArrayList
    val candidatesWithSameParameters = newArrayList

    for (candidate : eClassCandidates) {
      val eClassCand = candidate as EClass
      val opsWithSameName = eClassCand.EAllOperations.filter [ method |
        !(method === methodImpl) && method.name.equals(methodName)
      ]

      candidatesWithSameNames.addAll(opsWithSameName)

      if (!opsWithSameName.empty) {
        for (op : opsWithSameName) {

          var typesAreEqual = false
          /*def getEcoreSpecs(EObject elem) {
           * 	var gtcf = elem
           * 	while (gtcf !== null && !(gtcf instanceof GraphTransformationControlFlowFile)) {
           * 		gtcf = gtcf.eContainer
           * 	}
           * 	if (gtcf !== null) {
           * 		val file = gtcf as GraphTransformationControlFlowFile
           * 		val resources = file.imports.map[import|ControlFlowEditorModelUtil.loadEcoreModel(import.name)]
           * 		val epacks = EPackages
           * 	}
           }*/
          if ((methodImpl.EType === null && op.EType === null) || methodImpl.EType !== null && op.EType !== null &&
            methodImpl.EType.name.equals(op.EType.name)) {
            typesAreEqual = true
          }

          if (methodImpl.EParameters.size == op.EParameters.size) {
            val paramsMethod = methodImpl.EParameters
            val paramsCandidate = op.EParameters
            var parametersAreEqual = true
            for (var i = 0; i < paramsMethod.size; i++) {
              val paramMethod = paramsMethod.get(i)
              val paramCandidate = paramsCandidate.get(i)
              val paramCandidateType = paramCandidate.EType
              val paramMethodType = paramMethod.EType
              if (!(paramCandidateType !== null && paramMethodType !== null &&
                paramMethod.name.equals(paramCandidate.getName()) &&
                paramMethod.EType.name.equals(paramCandidate.EType.name))) {
                parametersAreEqual = false
              }
            }
            if (parametersAreEqual) {
              if (typesAreEqual) {
                return;
              } else {
                candidatesWithSameParameters.add(op);
              }
            }
          }
        }
      }

    }

    var String message = "Operation " + describe(methodImpl) + " missing from metamodel.";
    if (!candidatesWithSameParameters.empty) {
      message += " Possible candidates: " + candidatesWithSameParameters.map[describe(it)]
    } else if (!candidatesWithSameNames.empty) {
      message += " Possible candidates: " + candidatesWithSameNames.map[describe(it)]
    }

    error(message, methodImpl,
      MoslControlFlowPackage.Literals.METHOD_DEC.getEStructuralFeature(MoslControlFlowPackage.METHOD_DEC__NAME),
      MISSING_OPERATION)

  }

  def describe(MethodDec methodDec) {
    val formattedParameters = methodDec.EParameters.map[it.name + ":" + it.EType.name].join(",")
    var String returnType;
    if (methodDec.EType === null)
      returnType = "void"
    else
      returnType = methodDec.EType.name
    return String.format("%s::%s(%s):%s", (methodDec.eContainer as EClassDef).name.name, methodDec.name,
      formattedParameters, returnType)
  }

  def describe(EOperation operation) {
    val formattedParameters = operation.EParameters.map[it.name + ":" + it.EType.name].join(",")
    var String returnType;
    if (operation.EType === null)
      returnType = "void"
    else
      returnType = operation.EType.name
    return String.format("%s::%s(%s):%s", operation.EContainingClass.name, operation.name, formattedParameters,
      returnType)
  }

  @Check
  def uniqueMethodImplementations(MethodDecImpl methodImpl) {
    val methodName = methodImpl.name
    val eClass = methodImpl.eContainer as EClassDef
    val opsWithSameName = eClass.operations.filter [ method |
      !(method === methodImpl) && method.name.equals(methodName)
    ]
    var match = false
    if (!opsWithSameName.empty) {
      for (op : opsWithSameName) {
        var typesEqual = false
        if ((methodImpl.EType === null && op.EType === null) || methodImpl.EType !== null && op.EType !== null &&
          methodImpl.EType.name.equals(op.EType.name)) {
          typesEqual = true
        }
        if (typesEqual && methodImpl.EParameters.size == op.EParameters.size) {
          val paramsMethod = methodImpl.EParameters
          val paramsCandidate = op.EParameters
          var parametersMatch = true
          for (var i = 0; i < paramsMethod.size; i++) {
            val paramMethod = paramsMethod.get(i)
            val paramCandidate = paramsCandidate.get(i)
            val paramCandidateType = paramCandidate.EType
            val paramMethodType = paramMethod.EType
            if (!(paramCandidateType !== null && paramMethodType !== null &&
              paramMethod.name.equals(paramCandidate.getName()) &&
              paramMethod.EType.name.equals(paramCandidate.EType.name))) {
              parametersMatch = false
            }
          }
          if (parametersMatch) {
            match = true;
          }
        }
      }
      if (match) {
        error("Multiple declarations of same operation with name " + methodName, methodImpl,
          MoslControlFlowPackage.Literals.METHOD_DEC.getEStructuralFeature(MoslControlFlowPackage.METHOD_DEC__NAME),
          DUPLICATE_VARIABLE_NAME)
      } else {
        return
      }
    }
  }

  def getEClassCandidatesFromSpec(String eclassName, GraphTransformationControlFlowFile gtcf) {
    val resources = gtcf.imports.map[import|ControlFlowEditorModelUtil.loadEcoreModel(import.name)]
    val result = resources.filter[res|res.isPresent].map [ res |
      val resource = res.get
      val ePack = resource.contents.get(0) as EPackage
      return ePack.EClassifiers.filter[eClassifier|eClassifier.name.equals(eclassName)]
    ].filter(list|!list.empty).reduce[list1, list2|list1 + list2]
    return result

  }

  /**
   * Converts an integer into a "... times" String.
   */
  def static String getTimes(int count) {
    return if(count == 2) 'twice' else count + ' times'
  }

  @Check
  def isValidJavaIdentifier(ObjectVariableStatement oVarStmt) {
    if (!oVarStmt.name.equals("this") && !SourceVersion.isName(oVarStmt.name)) {
      error("ObjectVariable name is not a valid Java name: " + oVarStmt.name, oVarStmt,
        MoslControlFlowPackage.Literals.OBJECT_VARIABLE_STATEMENT.getEStructuralFeature(
          MoslControlFlowPackage.OBJECT_VARIABLE_STATEMENT__NAME), INVALID_NAME)
    }
  }

  def getControlFlowFile(EObject obj) {
    var gtcf = obj
    while (!(gtcf instanceof GraphTransformationControlFlowFile)) {
      gtcf = gtcf.eContainer
    }
    return gtcf as GraphTransformationControlFlowFile
  }

}
